/**
 * Dream Machine spec parser.
 *
 * Parses a Markdown spec (produced by Dream Machine Phase 1) into
 * structured sections that the build skill can act on.
 */

import type { ParsedSpec } from './types';

/**
 * Extract the first heading (# or ##) as the spec title.
 */
function extractTitle(markdown: string): string {
  const match = markdown.match(/^#{1,2}\s+(.+)$/m);
  return match ? match[1].trim() : 'Untitled Spec';
}

/**
 * Split markdown into sections by heading level 2 (##).
 * Returns a map of heading â†’ content.
 */
function splitSections(markdown: string): Record<string, string> {
  const sections: Record<string, string> = {};
  const lines = markdown.split('\n');
  let currentHeading = '_preamble';
  let currentContent: string[] = [];

  for (const line of lines) {
    const headingMatch = line.match(/^##\s+(.+)$/);
    if (headingMatch) {
      // Save previous section
      if (currentContent.length > 0) {
        sections[currentHeading] = currentContent.join('\n').trim();
      }
      currentHeading = headingMatch[1].trim().toLowerCase();
      currentContent = [];
    } else {
      currentContent.push(line);
    }
  }

  // Save last section
  if (currentContent.length > 0) {
    sections[currentHeading] = currentContent.join('\n').trim();
  }

  return sections;
}

/**
 * Extract bullet points from a section.
 * Recognises `- `, `* `, and numbered `1. ` list items.
 */
function extractBullets(text: string | undefined): string[] {
  if (!text) return [];
  const lines = text.split('\n');
  return lines
    .map(line => line.replace(/^\s*[-*]\s+/, '').replace(/^\s*\d+\.\s+/, '').trim())
    .filter(line => line.length > 0 && !line.startsWith('#'));
}

/**
 * Find a section by checking several possible heading names.
 * Uses word-boundary matching to avoid false positives
 * (e.g., "ui" should not match "requirements").
 */
function findSection(sections: Record<string, string>, candidates: string[]): string | undefined {
  for (const candidate of candidates) {
    if (candidate === '_preamble') {
      if (sections[candidate]) return sections[candidate];
      continue;
    }
    const pattern = new RegExp(`(?:^|\\s|\\b)${candidate}(?:\\s|\\b|$)`);
    const key = Object.keys(sections).find(k => pattern.test(k));
    if (key) return sections[key];
  }
  return undefined;
}

/**
 * Parse a Dream Machine spec markdown into structured data.
 */
export function parseSpecMarkdown(markdown: string): ParsedSpec {
  const title = extractTitle(markdown);
  const sections = splitSections(markdown);

  // Extract overview from preamble or overview/summary section
  const overviewText = findSection(sections, ['overview', 'summary', 'description', '_preamble']) ?? '';

  // Extract requirements
  const requirementsText = findSection(sections, ['requirements', 'features', 'scope', 'deliverables']);
  const requirements = extractBullets(requirementsText);

  // Extract API routes
  const apiRoutesText = findSection(sections, ['api', 'routes', 'endpoints']);
  const apiRoutes = extractBullets(apiRoutesText);

  // Extract DB changes
  const dbText = findSection(sections, ['database', 'db', 'schema', 'migrations']);
  const dbChanges = extractBullets(dbText);

  // Extract UI components
  const uiText = findSection(sections, ['ui', 'components', 'frontend', 'interface']);
  const uiComponents = extractBullets(uiText);

  return {
    title,
    overview: overviewText,
    requirements,
    apiRoutes,
    dbChanges,
    uiComponents,
    rawSections: sections,
  };
}

/**
 * Generate a PR body from a parsed spec.
 */
export function generatePRBody(parsed: ParsedSpec, filesChanged: string[]): string {
  const sections: string[] = [
    `## Dream Machine Build`,
    '',
    `**Spec**: ${parsed.title}`,
    '',
  ];

  if (parsed.overview) {
    sections.push('### Overview', '', parsed.overview.slice(0, 500), '');
  }

  if (parsed.requirements.length > 0) {
    sections.push('### Requirements', '');
    for (const req of parsed.requirements.slice(0, 10)) {
      sections.push(`- ${req}`);
    }
    sections.push('');
  }

  if (filesChanged.length > 0) {
    sections.push('### Files Changed', '');
    for (const file of filesChanged) {
      sections.push(`- \`${file}\``);
    }
    sections.push('');
  }

  sections.push(
    '---',
    '*Generated by Dream Machine Build stage via Moltworker*',
  );

  return sections.join('\n');
}

/**
 * Create a URL-safe slug from a title.
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50);
}
